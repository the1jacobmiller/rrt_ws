// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: multi_lidar_fusion_config.proto

#ifndef PROTOBUF_INCLUDED_multi_5flidar_5ffusion_5fconfig_2eproto
#define PROTOBUF_INCLUDED_multi_5flidar_5ffusion_5fconfig_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_multi_5flidar_5ffusion_5fconfig_2eproto 

namespace protobuf_multi_5flidar_5ffusion_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_multi_5flidar_5ffusion_5fconfig_2eproto
namespace apollo {
namespace perception {
namespace lidar {
class MlfDistanceConfig;
class MlfDistanceConfigDefaultTypeInternal;
extern MlfDistanceConfigDefaultTypeInternal _MlfDistanceConfig_default_instance_;
class MlfDistanceWeight;
class MlfDistanceWeightDefaultTypeInternal;
extern MlfDistanceWeightDefaultTypeInternal _MlfDistanceWeight_default_instance_;
class MlfEngineConfig;
class MlfEngineConfigDefaultTypeInternal;
extern MlfEngineConfigDefaultTypeInternal _MlfEngineConfig_default_instance_;
class MlfMotionFilterConfig;
class MlfMotionFilterConfigDefaultTypeInternal;
extern MlfMotionFilterConfigDefaultTypeInternal _MlfMotionFilterConfig_default_instance_;
class MlfMotionRefinerConfig;
class MlfMotionRefinerConfigDefaultTypeInternal;
extern MlfMotionRefinerConfigDefaultTypeInternal _MlfMotionRefinerConfig_default_instance_;
class MlfShapeFilterConfig;
class MlfShapeFilterConfigDefaultTypeInternal;
extern MlfShapeFilterConfigDefaultTypeInternal _MlfShapeFilterConfig_default_instance_;
class MlfTrackObjectMatcherConfig;
class MlfTrackObjectMatcherConfigDefaultTypeInternal;
extern MlfTrackObjectMatcherConfigDefaultTypeInternal _MlfTrackObjectMatcherConfig_default_instance_;
class MlfTrackerConfig;
class MlfTrackerConfigDefaultTypeInternal;
extern MlfTrackerConfigDefaultTypeInternal _MlfTrackerConfig_default_instance_;
}  // namespace lidar
}  // namespace perception
}  // namespace apollo
namespace google {
namespace protobuf {
template<> ::apollo::perception::lidar::MlfDistanceConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfDistanceConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfDistanceWeight* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfDistanceWeight>(Arena*);
template<> ::apollo::perception::lidar::MlfEngineConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfEngineConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfMotionFilterConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfMotionFilterConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfMotionRefinerConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfMotionRefinerConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfShapeFilterConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfShapeFilterConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfTrackObjectMatcherConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfTrackObjectMatcherConfig>(Arena*);
template<> ::apollo::perception::lidar::MlfTrackerConfig* Arena::CreateMaybeMessage<::apollo::perception::lidar::MlfTrackerConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace apollo {
namespace perception {
namespace lidar {

// ===================================================================

class MlfDistanceWeight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfDistanceWeight) */ {
 public:
  MlfDistanceWeight();
  virtual ~MlfDistanceWeight();

  MlfDistanceWeight(const MlfDistanceWeight& from);

  inline MlfDistanceWeight& operator=(const MlfDistanceWeight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MlfDistanceWeight(MlfDistanceWeight&& from) noexcept
    : MlfDistanceWeight() {
    *this = ::std::move(from);
  }

  inline MlfDistanceWeight& operator=(MlfDistanceWeight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MlfDistanceWeight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MlfDistanceWeight* internal_default_instance() {
    return reinterpret_cast<const MlfDistanceWeight*>(
               &_MlfDistanceWeight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MlfDistanceWeight* other);
  friend void swap(MlfDistanceWeight& a, MlfDistanceWeight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MlfDistanceWeight* New() const final {
    return CreateMaybeMessage<MlfDistanceWeight>(NULL);
  }

  MlfDistanceWeight* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MlfDistanceWeight>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MlfDistanceWeight& from);
  void MergeFrom(const MlfDistanceWeight& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfDistanceWeight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sensor_name_pair = 1 [default = ""];
  bool has_sensor_name_pair() const;
  void clear_sensor_name_pair();
  static const int kSensorNamePairFieldNumber = 1;
  const ::std::string& sensor_name_pair() const;
  void set_sensor_name_pair(const ::std::string& value);
  #if LANG_CXX11
  void set_sensor_name_pair(::std::string&& value);
  #endif
  void set_sensor_name_pair(const char* value);
  void set_sensor_name_pair(const char* value, size_t size);
  ::std::string* mutable_sensor_name_pair();
  ::std::string* release_sensor_name_pair();
  void set_allocated_sensor_name_pair(::std::string* sensor_name_pair);

  // optional float location_dist_weight = 2 [default = 0];
  bool has_location_dist_weight() const;
  void clear_location_dist_weight();
  static const int kLocationDistWeightFieldNumber = 2;
  float location_dist_weight() const;
  void set_location_dist_weight(float value);

  // optional float direction_dist_weight = 3 [default = 0];
  bool has_direction_dist_weight() const;
  void clear_direction_dist_weight();
  static const int kDirectionDistWeightFieldNumber = 3;
  float direction_dist_weight() const;
  void set_direction_dist_weight(float value);

  // optional float bbox_size_dist_weight = 4 [default = 0];
  bool has_bbox_size_dist_weight() const;
  void clear_bbox_size_dist_weight();
  static const int kBboxSizeDistWeightFieldNumber = 4;
  float bbox_size_dist_weight() const;
  void set_bbox_size_dist_weight(float value);

  // optional float point_num_dist_weight = 5 [default = 0];
  bool has_point_num_dist_weight() const;
  void clear_point_num_dist_weight();
  static const int kPointNumDistWeightFieldNumber = 5;
  float point_num_dist_weight() const;
  void set_point_num_dist_weight(float value);

  // optional float histogram_dist_weight = 6 [default = 0];
  bool has_histogram_dist_weight() const;
  void clear_histogram_dist_weight();
  static const int kHistogramDistWeightFieldNumber = 6;
  float histogram_dist_weight() const;
  void set_histogram_dist_weight(float value);

  // optional float centroid_shift_dist_weight = 7 [default = 0];
  bool has_centroid_shift_dist_weight() const;
  void clear_centroid_shift_dist_weight();
  static const int kCentroidShiftDistWeightFieldNumber = 7;
  float centroid_shift_dist_weight() const;
  void set_centroid_shift_dist_weight(float value);

  // optional float bbox_iou_dist_weight = 8 [default = 0];
  bool has_bbox_iou_dist_weight() const;
  void clear_bbox_iou_dist_weight();
  static const int kBboxIouDistWeightFieldNumber = 8;
  float bbox_iou_dist_weight() const;
  void set_bbox_iou_dist_weight(float value);

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfDistanceWeight)
 private:
  void set_has_sensor_name_pair();
  void clear_has_sensor_name_pair();
  void set_has_location_dist_weight();
  void clear_has_location_dist_weight();
  void set_has_direction_dist_weight();
  void clear_has_direction_dist_weight();
  void set_has_bbox_size_dist_weight();
  void clear_has_bbox_size_dist_weight();
  void set_has_point_num_dist_weight();
  void clear_has_point_num_dist_weight();
  void set_has_histogram_dist_weight();
  void clear_has_histogram_dist_weight();
  void set_has_centroid_shift_dist_weight();
  void clear_has_centroid_shift_dist_weight();
  void set_has_bbox_iou_dist_weight();
  void clear_has_bbox_iou_dist_weight();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sensor_name_pair_;
  float location_dist_weight_;
  float direction_dist_weight_;
  float bbox_size_dist_weight_;
  float point_num_dist_weight_;
  float histogram_dist_weight_;
  float centroid_shift_dist_weight_;
  float bbox_iou_dist_weight_;
  friend struct ::protobuf_multi_5flidar_5ffusion_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MlfDistanceConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfDistanceConfig) */ {
 public:
  MlfDistanceConfig();
  virtual ~MlfDistanceConfig();

  MlfDistanceConfig(const MlfDistanceConfig& from);

  inline MlfDistanceConfig& operator=(const MlfDistanceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MlfDistanceConfig(MlfDistanceConfig&& from) noexcept
    : MlfDistanceConfig() {
    *this = ::std::move(from);
  }

  inline MlfDistanceConfig& operator=(MlfDistanceConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MlfDistanceConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MlfDistanceConfig* internal_default_instance() {
    return reinterpret_cast<const MlfDistanceConfig*>(
               &_MlfDistanceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MlfDistanceConfig* other);
  friend void swap(MlfDistanceConfig& a, MlfDistanceConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MlfDistanceConfig* New() const final {
    return CreateMaybeMessage<MlfDistanceConfig>(NULL);
  }

  MlfDistanceConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MlfDistanceConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MlfDistanceConfig& from);
  void MergeFrom(const MlfDistanceConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfDistanceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.perception.lidar.MlfDistanceWeight foreground_weights = 1;
  int foreground_weights_size() const;
  void clear_foreground_weights();
  static const int kForegroundWeightsFieldNumber = 1;
  ::apollo::perception::lidar::MlfDistanceWeight* mutable_foreground_weights(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >*
      mutable_foreground_weights();
  const ::apollo::perception::lidar::MlfDistanceWeight& foreground_weights(int index) const;
  ::apollo::perception::lidar::MlfDistanceWeight* add_foreground_weights();
  const ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >&
      foreground_weights() const;

  // repeated .apollo.perception.lidar.MlfDistanceWeight background_weights = 2;
  int background_weights_size() const;
  void clear_background_weights();
  static const int kBackgroundWeightsFieldNumber = 2;
  ::apollo::perception::lidar::MlfDistanceWeight* mutable_background_weights(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >*
      mutable_background_weights();
  const ::apollo::perception::lidar::MlfDistanceWeight& background_weights(int index) const;
  ::apollo::perception::lidar::MlfDistanceWeight* add_background_weights();
  const ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >&
      background_weights() const;

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfDistanceConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight > foreground_weights_;
  ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight > background_weights_;
  friend struct ::protobuf_multi_5flidar_5ffusion_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MlfTrackObjectMatcherConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfTrackObjectMatcherConfig) */ {
 public:
  MlfTrackObjectMatcherConfig();
  virtual ~MlfTrackObjectMatcherConfig();

  MlfTrackObjectMatcherConfig(const MlfTrackObjectMatcherConfig& from);

  inline MlfTrackObjectMatcherConfig& operator=(const MlfTrackObjectMatcherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MlfTrackObjectMatcherConfig(MlfTrackObjectMatcherConfig&& from) noexcept
    : MlfTrackObjectMatcherConfig() {
    *this = ::std::move(from);
  }

  inline MlfTrackObjectMatcherConfig& operator=(MlfTrackObjectMatcherConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MlfTrackObjectMatcherConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MlfTrackObjectMatcherConfig* internal_default_instance() {
    return reinterpret_cast<const MlfTrackObjectMatcherConfig*>(
               &_MlfTrackObjectMatcherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MlfTrackObjectMatcherConfig* other);
  friend void swap(MlfTrackObjectMatcherConfig& a, MlfTrackObjectMatcherConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MlfTrackObjectMatcherConfig* New() const final {
    return CreateMaybeMessage<MlfTrackObjectMatcherConfig>(NULL);
  }

  MlfTrackObjectMatcherConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MlfTrackObjectMatcherConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MlfTrackObjectMatcherConfig& from);
  void MergeFrom(const MlfTrackObjectMatcherConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfTrackObjectMatcherConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string foreground_mathcer_method = 1 [default = "MultiHmBipartiteGraphMatcher"];
  bool has_foreground_mathcer_method() const;
  void clear_foreground_mathcer_method();
  static const int kForegroundMathcerMethodFieldNumber = 1;
  const ::std::string& foreground_mathcer_method() const;
  void set_foreground_mathcer_method(const ::std::string& value);
  #if LANG_CXX11
  void set_foreground_mathcer_method(::std::string&& value);
  #endif
  void set_foreground_mathcer_method(const char* value);
  void set_foreground_mathcer_method(const char* value, size_t size);
  ::std::string* mutable_foreground_mathcer_method();
  ::std::string* release_foreground_mathcer_method();
  void set_allocated_foreground_mathcer_method(::std::string* foreground_mathcer_method);

  // optional string background_matcher_method = 2 [default = "GnnBipartiteGraphMatcher"];
  bool has_background_matcher_method() const;
  void clear_background_matcher_method();
  static const int kBackgroundMatcherMethodFieldNumber = 2;
  const ::std::string& background_matcher_method() const;
  void set_background_matcher_method(const ::std::string& value);
  #if LANG_CXX11
  void set_background_matcher_method(::std::string&& value);
  #endif
  void set_background_matcher_method(const char* value);
  void set_background_matcher_method(const char* value, size_t size);
  ::std::string* mutable_background_matcher_method();
  ::std::string* release_background_matcher_method();
  void set_allocated_background_matcher_method(::std::string* background_matcher_method);

  // optional float bound_value = 3 [default = 100];
  bool has_bound_value() const;
  void clear_bound_value();
  static const int kBoundValueFieldNumber = 3;
  float bound_value() const;
  void set_bound_value(float value);

  // optional float max_match_distance = 4 [default = 4];
  bool has_max_match_distance() const;
  void clear_max_match_distance();
  static const int kMaxMatchDistanceFieldNumber = 4;
  float max_match_distance() const;
  void set_max_match_distance(float value);

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfTrackObjectMatcherConfig)
 private:
  void set_has_foreground_mathcer_method();
  void clear_has_foreground_mathcer_method();
  void set_has_background_matcher_method();
  void clear_has_background_matcher_method();
  void set_has_bound_value();
  void clear_has_bound_value();
  void set_has_max_match_distance();
  void clear_has_max_match_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_foreground_mathcer_method_;
  private:
  ::google::protobuf::internal::ArenaStringPtr foreground_mathcer_method_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_background_matcher_method_;
  private:
  ::google::protobuf::internal::ArenaStringPtr background_matcher_method_;
  float bound_value_;
  float max_match_distance_;
  friend struct ::protobuf_multi_5flidar_5ffusion_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MlfTrackerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfTrackerConfig) */ {
 public:
  MlfTrackerConfig();
  virtual ~MlfTrackerConfig();

  MlfTrackerConfig(const MlfTrackerConfig& from);

  inline MlfTrackerConfig& operator=(const MlfTrackerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MlfTrackerConfig(MlfTrackerConfig&& from) noexcept
    : MlfTrackerConfig() {
    *this = ::std::move(from);
  }

  inline MlfTrackerConfig& operator=(MlfTrackerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MlfTrackerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MlfTrackerConfig* internal_default_instance() {
    return reinterpret_cast<const MlfTrackerConfig*>(
               &_MlfTrackerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MlfTrackerConfig* other);
  friend void swap(MlfTrackerConfig& a, MlfTrackerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MlfTrackerConfig* New() const final {
    return CreateMaybeMessage<MlfTrackerConfig>(NULL);
  }

  MlfTrackerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MlfTrackerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MlfTrackerConfig& from);
  void MergeFrom(const MlfTrackerConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfTrackerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string filter_name = 1;
  int filter_name_size() const;
  void clear_filter_name();
  static const int kFilterNameFieldNumber = 1;
  const ::std::string& filter_name(int index) const;
  ::std::string* mutable_filter_name(int index);
  void set_filter_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_filter_name(int index, ::std::string&& value);
  #endif
  void set_filter_name(int index, const char* value);
  void set_filter_name(int index, const char* value, size_t size);
  ::std::string* add_filter_name();
  void add_filter_name(const ::std::string& value);
  #if LANG_CXX11
  void add_filter_name(::std::string&& value);
  #endif
  void add_filter_name(const char* value);
  void add_filter_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_name();

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfTrackerConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_name_;
  friend struct ::protobuf_multi_5flidar_5ffusion_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MlfMotionFilterConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfMotionFilterConfig) */ {
 public:
  MlfMotionFilterConfig();
  virtual ~MlfMotionFilterConfig();

  MlfMotionFilterConfig(const MlfMotionFilterConfig& from);

  inline MlfMotionFilterConfig& operator=(const MlfMotionFilterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MlfMotionFilterConfig(MlfMotionFilterConfig&& from) noexcept
    : MlfMotionFilterConfig() {
    *this = ::std::move(from);
  }

  inline MlfMotionFilterConfig& operator=(MlfMotionFilterConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MlfMotionFilterConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MlfMotionFilterConfig* internal_default_instance() {
    return reinterpret_cast<const MlfMotionFilterConfig*>(
               &_MlfMotionFilterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MlfMotionFilterConfig* other);
  friend void swap(MlfMotionFilterConfig& a, MlfMotionFilterConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MlfMotionFilterConfig* New() const final {
    return CreateMaybeMessage<MlfMotionFilterConfig>(NULL);
  }

  MlfMotionFilterConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MlfMotionFilterConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MlfMotionFilterConfig& from);
  void MergeFrom(const MlfMotionFilterConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfMotionFilterConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 boostup_history_size_maximum = 9 [default = 6];
  bool has_boostup_history_size_maximum() const;
  void clear_boostup_history_size_maximum();
  static const int kBoostupHistorySizeMaximumFieldNumber = 9;
  ::google::protobuf::uint32 boostup_history_size_maximum() const;
  void set_boostup_history_size_maximum(::google::protobuf::uint32 value);

  // optional bool use_adaptive = 1 [default = true];
  bool has_use_adaptive() const;
  void clear_use_adaptive();
  static const int kUseAdaptiveFieldNumber = 1;
  bool use_adaptive() const;
  void set_use_adaptive(bool value);

  // optional bool use_breakdown = 2 [default = true];
  bool has_use_breakdown() const;
  void clear_use_breakdown();
  static const int kUseBreakdownFieldNumber = 2;
  bool use_breakdown() const;
  void set_use_breakdown(bool value);

  // optional bool use_convergence_boostup = 3 [default = true];
  bool has_use_convergence_boostup() const;
  void clear_use_convergence_boostup();
  static const int kUseConvergenceBoostupFieldNumber = 3;
  bool use_convergence_boostup() const;
  void set_use_convergence_boostup(bool value);

  // optional uint32 boostup_history_size_minimum = 8 [default = 3];
  bool has_boostup_history_size_minimum() const;
  void clear_boostup_history_size_minimum();
  static const int kBoostupHistorySizeMinimumFieldNumber = 8;
  ::google::protobuf::uint32 boostup_history_size_minimum() const;
  void set_boostup_history_size_minimum(::google::protobuf::uint32 value);

  // optional double init_velocity_variance = 4 [default = 5];
  bool has_init_velocity_variance() const;
  void clear_init_velocity_variance();
  static const int kInitVelocityVarianceFieldNumber = 4;
  double init_velocity_variance() const;
  void set_init_velocity_variance(double value);

  // optional double init_acceleration_variance = 5 [default = 10];
  bool has_init_acceleration_variance() const;
  void clear_init_acceleration_variance();
  static const int kInitAccelerationVarianceFieldNumber = 5;
  double init_acceleration_variance() const;
  void set_init_acceleration_variance(double value);

  // optional double measured_velocity_variance = 6 [default = 0.4];
  bool has_measured_velocity_variance() const;
  void clear_measured_velocity_variance();
  static const int kMeasuredVelocityVarianceFieldNumber = 6;
  double measured_velocity_variance() const;
  void set_measured_velocity_variance(double value);

  // optional double predict_variance_per_sqrsec = 7 [default = 10];
  bool has_predict_variance_per_sqrsec() const;
  void clear_predict_variance_per_sqrsec();
  static const int kPredictVariancePerSqrsecFieldNumber = 7;
  double predict_variance_per_sqrsec() const;
  void set_predict_variance_per_sqrsec(double value);

  // optional double converged_confidence_minimum = 10 [default = 0.5];
  bool has_converged_confidence_minimum() const;
  void clear_converged_confidence_minimum();
  static const int kConvergedConfidenceMinimumFieldNumber = 10;
  double converged_confidence_minimum() const;
  void set_converged_confidence_minimum(double value);

  // optional double noise_maximum = 12 [default = 0.1];
  bool has_noise_maximum() const;
  void clear_noise_maximum();
  static const int kNoiseMaximumFieldNumber = 12;
  double noise_maximum() const;
  void set_noise_maximum(double value);

  // optional double trust_orientation_range = 13 [default = 40];
  bool has_trust_orientation_range() const;
  void clear_trust_orientation_range();
  static const int kTrustOrientationRangeFieldNumber = 13;
  double trust_orientation_range() const;
  void set_trust_orientation_range(double value);

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfMotionFilterConfig)
 private:
  void set_has_use_adaptive();
  void clear_has_use_adaptive();
  void set_has_use_breakdown();
  void clear_has_use_breakdown();
  void set_has_use_convergence_boostup();
  void clear_has_use_convergence_boostup();
  void set_has_init_velocity_variance();
  void clear_has_init_velocity_variance();
  void set_has_init_acceleration_variance();
  void clear_has_init_acceleration_variance();
  void set_has_measured_velocity_variance();
  void clear_has_measured_velocity_variance();
  void set_has_predict_variance_per_sqrsec();
  void clear_has_predict_variance_per_sqrsec();
  void set_has_boostup_history_size_minimum();
  void clear_has_boostup_history_size_minimum();
  void set_has_boostup_history_size_maximum();
  void clear_has_boostup_history_size_maximum();
  void set_has_converged_confidence_minimum();
  void clear_has_converged_confidence_minimum();
  void set_has_noise_maximum();
  void clear_has_noise_maximum();
  void set_has_trust_orientation_range();
  void clear_has_trust_orientation_range();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 boostup_history_size_maximum_;
  bool use_adaptive_;
  bool use_breakdown_;
  bool use_convergence_boostup_;
  ::google::protobuf::uint32 boostup_history_size_minimum_;
  double init_velocity_variance_;
  double init_acceleration_variance_;
  double measured_velocity_variance_;
  double predict_variance_per_sqrsec_;
  double converged_confidence_minimum_;
  double noise_maximum_;
  double trust_orientation_range_;
  friend struct ::protobuf_multi_5flidar_5ffusion_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MlfMotionRefinerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfMotionRefinerConfig) */ {
 public:
  MlfMotionRefinerConfig();
  virtual ~MlfMotionRefinerConfig();

  MlfMotionRefinerConfig(const MlfMotionRefinerConfig& from);

  inline MlfMotionRefinerConfig& operator=(const MlfMotionRefinerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MlfMotionRefinerConfig(MlfMotionRefinerConfig&& from) noexcept
    : MlfMotionRefinerConfig() {
    *this = ::std::move(from);
  }

  inline MlfMotionRefinerConfig& operator=(MlfMotionRefinerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MlfMotionRefinerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MlfMotionRefinerConfig* internal_default_instance() {
    return reinterpret_cast<const MlfMotionRefinerConfig*>(
               &_MlfMotionRefinerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MlfMotionRefinerConfig* other);
  friend void swap(MlfMotionRefinerConfig& a, MlfMotionRefinerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MlfMotionRefinerConfig* New() const final {
    return CreateMaybeMessage<MlfMotionRefinerConfig>(NULL);
  }

  MlfMotionRefinerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MlfMotionRefinerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MlfMotionRefinerConfig& from);
  void MergeFrom(const MlfMotionRefinerConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfMotionRefinerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double claping_acceleration_threshold = 1 [default = 10];
  bool has_claping_acceleration_threshold() const;
  void clear_claping_acceleration_threshold();
  static const int kClapingAccelerationThresholdFieldNumber = 1;
  double claping_acceleration_threshold() const;
  void set_claping_acceleration_threshold(double value);

  // optional double claping_speed_threshold = 2 [default = 1];
  bool has_claping_speed_threshold() const;
  void clear_claping_speed_threshold();
  static const int kClapingSpeedThresholdFieldNumber = 2;
  double claping_speed_threshold() const;
  void set_claping_speed_threshold(double value);

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfMotionRefinerConfig)
 private:
  void set_has_claping_acceleration_threshold();
  void clear_has_claping_acceleration_threshold();
  void set_has_claping_speed_threshold();
  void clear_has_claping_speed_threshold();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double claping_acceleration_threshold_;
  double claping_speed_threshold_;
  friend struct ::protobuf_multi_5flidar_5ffusion_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MlfShapeFilterConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfShapeFilterConfig) */ {
 public:
  MlfShapeFilterConfig();
  virtual ~MlfShapeFilterConfig();

  MlfShapeFilterConfig(const MlfShapeFilterConfig& from);

  inline MlfShapeFilterConfig& operator=(const MlfShapeFilterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MlfShapeFilterConfig(MlfShapeFilterConfig&& from) noexcept
    : MlfShapeFilterConfig() {
    *this = ::std::move(from);
  }

  inline MlfShapeFilterConfig& operator=(MlfShapeFilterConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MlfShapeFilterConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MlfShapeFilterConfig* internal_default_instance() {
    return reinterpret_cast<const MlfShapeFilterConfig*>(
               &_MlfShapeFilterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MlfShapeFilterConfig* other);
  friend void swap(MlfShapeFilterConfig& a, MlfShapeFilterConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MlfShapeFilterConfig* New() const final {
    return CreateMaybeMessage<MlfShapeFilterConfig>(NULL);
  }

  MlfShapeFilterConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MlfShapeFilterConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MlfShapeFilterConfig& from);
  void MergeFrom(const MlfShapeFilterConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfShapeFilterConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double bottom_points_ignore_threshold = 1 [default = 0.1];
  bool has_bottom_points_ignore_threshold() const;
  void clear_bottom_points_ignore_threshold();
  static const int kBottomPointsIgnoreThresholdFieldNumber = 1;
  double bottom_points_ignore_threshold() const;
  void set_bottom_points_ignore_threshold(double value);

  // optional double top_points_ignore_threshold = 2 [default = 1.6];
  bool has_top_points_ignore_threshold() const;
  void clear_top_points_ignore_threshold();
  static const int kTopPointsIgnoreThresholdFieldNumber = 2;
  double top_points_ignore_threshold() const;
  void set_top_points_ignore_threshold(double value);

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfShapeFilterConfig)
 private:
  void set_has_bottom_points_ignore_threshold();
  void clear_has_bottom_points_ignore_threshold();
  void set_has_top_points_ignore_threshold();
  void clear_has_top_points_ignore_threshold();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double bottom_points_ignore_threshold_;
  double top_points_ignore_threshold_;
  friend struct ::protobuf_multi_5flidar_5ffusion_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MlfEngineConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.perception.lidar.MlfEngineConfig) */ {
 public:
  MlfEngineConfig();
  virtual ~MlfEngineConfig();

  MlfEngineConfig(const MlfEngineConfig& from);

  inline MlfEngineConfig& operator=(const MlfEngineConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MlfEngineConfig(MlfEngineConfig&& from) noexcept
    : MlfEngineConfig() {
    *this = ::std::move(from);
  }

  inline MlfEngineConfig& operator=(MlfEngineConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MlfEngineConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MlfEngineConfig* internal_default_instance() {
    return reinterpret_cast<const MlfEngineConfig*>(
               &_MlfEngineConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MlfEngineConfig* other);
  friend void swap(MlfEngineConfig& a, MlfEngineConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MlfEngineConfig* New() const final {
    return CreateMaybeMessage<MlfEngineConfig>(NULL);
  }

  MlfEngineConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MlfEngineConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MlfEngineConfig& from);
  void MergeFrom(const MlfEngineConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MlfEngineConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string main_sensor = 1;
  int main_sensor_size() const;
  void clear_main_sensor();
  static const int kMainSensorFieldNumber = 1;
  const ::std::string& main_sensor(int index) const;
  ::std::string* mutable_main_sensor(int index);
  void set_main_sensor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_main_sensor(int index, ::std::string&& value);
  #endif
  void set_main_sensor(int index, const char* value);
  void set_main_sensor(int index, const char* value, size_t size);
  ::std::string* add_main_sensor();
  void add_main_sensor(const ::std::string& value);
  #if LANG_CXX11
  void add_main_sensor(::std::string&& value);
  #endif
  void add_main_sensor(const char* value);
  void add_main_sensor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& main_sensor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_main_sensor();

  // optional bool output_predict_objects = 4 [default = false];
  bool has_output_predict_objects() const;
  void clear_output_predict_objects();
  static const int kOutputPredictObjectsFieldNumber = 4;
  bool output_predict_objects() const;
  void set_output_predict_objects(bool value);

  // optional bool use_frame_timestamp = 6 [default = false];
  bool has_use_frame_timestamp() const;
  void clear_use_frame_timestamp();
  static const int kUseFrameTimestampFieldNumber = 6;
  bool use_frame_timestamp() const;
  void set_use_frame_timestamp(bool value);

  // optional bool use_histogram_for_match = 2 [default = true];
  bool has_use_histogram_for_match() const;
  void clear_use_histogram_for_match();
  static const int kUseHistogramForMatchFieldNumber = 2;
  bool use_histogram_for_match() const;
  void set_use_histogram_for_match(bool value);

  // optional uint32 histogram_bin_size = 3 [default = 10];
  bool has_histogram_bin_size() const;
  void clear_histogram_bin_size();
  static const int kHistogramBinSizeFieldNumber = 3;
  ::google::protobuf::uint32 histogram_bin_size() const;
  void set_histogram_bin_size(::google::protobuf::uint32 value);

  // optional double reserved_invisible_time = 5 [default = 0.2];
  bool has_reserved_invisible_time() const;
  void clear_reserved_invisible_time();
  static const int kReservedInvisibleTimeFieldNumber = 5;
  double reserved_invisible_time() const;
  void set_reserved_invisible_time(double value);

  // @@protoc_insertion_point(class_scope:apollo.perception.lidar.MlfEngineConfig)
 private:
  void set_has_use_histogram_for_match();
  void clear_has_use_histogram_for_match();
  void set_has_histogram_bin_size();
  void clear_has_histogram_bin_size();
  void set_has_output_predict_objects();
  void clear_has_output_predict_objects();
  void set_has_reserved_invisible_time();
  void clear_has_reserved_invisible_time();
  void set_has_use_frame_timestamp();
  void clear_has_use_frame_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> main_sensor_;
  bool output_predict_objects_;
  bool use_frame_timestamp_;
  bool use_histogram_for_match_;
  ::google::protobuf::uint32 histogram_bin_size_;
  double reserved_invisible_time_;
  friend struct ::protobuf_multi_5flidar_5ffusion_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MlfDistanceWeight

// optional string sensor_name_pair = 1 [default = ""];
inline bool MlfDistanceWeight::has_sensor_name_pair() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MlfDistanceWeight::set_has_sensor_name_pair() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MlfDistanceWeight::clear_has_sensor_name_pair() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MlfDistanceWeight::clear_sensor_name_pair() {
  sensor_name_pair_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensor_name_pair();
}
inline const ::std::string& MlfDistanceWeight::sensor_name_pair() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
  return sensor_name_pair_.GetNoArena();
}
inline void MlfDistanceWeight::set_sensor_name_pair(const ::std::string& value) {
  set_has_sensor_name_pair();
  sensor_name_pair_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
}
#if LANG_CXX11
inline void MlfDistanceWeight::set_sensor_name_pair(::std::string&& value) {
  set_has_sensor_name_pair();
  sensor_name_pair_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
}
#endif
inline void MlfDistanceWeight::set_sensor_name_pair(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sensor_name_pair();
  sensor_name_pair_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
}
inline void MlfDistanceWeight::set_sensor_name_pair(const char* value, size_t size) {
  set_has_sensor_name_pair();
  sensor_name_pair_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
}
inline ::std::string* MlfDistanceWeight::mutable_sensor_name_pair() {
  set_has_sensor_name_pair();
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
  return sensor_name_pair_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MlfDistanceWeight::release_sensor_name_pair() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
  if (!has_sensor_name_pair()) {
    return NULL;
  }
  clear_has_sensor_name_pair();
  return sensor_name_pair_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MlfDistanceWeight::set_allocated_sensor_name_pair(::std::string* sensor_name_pair) {
  if (sensor_name_pair != NULL) {
    set_has_sensor_name_pair();
  } else {
    clear_has_sensor_name_pair();
  }
  sensor_name_pair_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_name_pair);
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.MlfDistanceWeight.sensor_name_pair)
}

// optional float location_dist_weight = 2 [default = 0];
inline bool MlfDistanceWeight::has_location_dist_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MlfDistanceWeight::set_has_location_dist_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MlfDistanceWeight::clear_has_location_dist_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MlfDistanceWeight::clear_location_dist_weight() {
  location_dist_weight_ = 0;
  clear_has_location_dist_weight();
}
inline float MlfDistanceWeight::location_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.location_dist_weight)
  return location_dist_weight_;
}
inline void MlfDistanceWeight::set_location_dist_weight(float value) {
  set_has_location_dist_weight();
  location_dist_weight_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.location_dist_weight)
}

// optional float direction_dist_weight = 3 [default = 0];
inline bool MlfDistanceWeight::has_direction_dist_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MlfDistanceWeight::set_has_direction_dist_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MlfDistanceWeight::clear_has_direction_dist_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MlfDistanceWeight::clear_direction_dist_weight() {
  direction_dist_weight_ = 0;
  clear_has_direction_dist_weight();
}
inline float MlfDistanceWeight::direction_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.direction_dist_weight)
  return direction_dist_weight_;
}
inline void MlfDistanceWeight::set_direction_dist_weight(float value) {
  set_has_direction_dist_weight();
  direction_dist_weight_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.direction_dist_weight)
}

// optional float bbox_size_dist_weight = 4 [default = 0];
inline bool MlfDistanceWeight::has_bbox_size_dist_weight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MlfDistanceWeight::set_has_bbox_size_dist_weight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MlfDistanceWeight::clear_has_bbox_size_dist_weight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MlfDistanceWeight::clear_bbox_size_dist_weight() {
  bbox_size_dist_weight_ = 0;
  clear_has_bbox_size_dist_weight();
}
inline float MlfDistanceWeight::bbox_size_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.bbox_size_dist_weight)
  return bbox_size_dist_weight_;
}
inline void MlfDistanceWeight::set_bbox_size_dist_weight(float value) {
  set_has_bbox_size_dist_weight();
  bbox_size_dist_weight_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.bbox_size_dist_weight)
}

// optional float point_num_dist_weight = 5 [default = 0];
inline bool MlfDistanceWeight::has_point_num_dist_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MlfDistanceWeight::set_has_point_num_dist_weight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MlfDistanceWeight::clear_has_point_num_dist_weight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MlfDistanceWeight::clear_point_num_dist_weight() {
  point_num_dist_weight_ = 0;
  clear_has_point_num_dist_weight();
}
inline float MlfDistanceWeight::point_num_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.point_num_dist_weight)
  return point_num_dist_weight_;
}
inline void MlfDistanceWeight::set_point_num_dist_weight(float value) {
  set_has_point_num_dist_weight();
  point_num_dist_weight_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.point_num_dist_weight)
}

// optional float histogram_dist_weight = 6 [default = 0];
inline bool MlfDistanceWeight::has_histogram_dist_weight() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MlfDistanceWeight::set_has_histogram_dist_weight() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MlfDistanceWeight::clear_has_histogram_dist_weight() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MlfDistanceWeight::clear_histogram_dist_weight() {
  histogram_dist_weight_ = 0;
  clear_has_histogram_dist_weight();
}
inline float MlfDistanceWeight::histogram_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.histogram_dist_weight)
  return histogram_dist_weight_;
}
inline void MlfDistanceWeight::set_histogram_dist_weight(float value) {
  set_has_histogram_dist_weight();
  histogram_dist_weight_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.histogram_dist_weight)
}

// optional float centroid_shift_dist_weight = 7 [default = 0];
inline bool MlfDistanceWeight::has_centroid_shift_dist_weight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MlfDistanceWeight::set_has_centroid_shift_dist_weight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MlfDistanceWeight::clear_has_centroid_shift_dist_weight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MlfDistanceWeight::clear_centroid_shift_dist_weight() {
  centroid_shift_dist_weight_ = 0;
  clear_has_centroid_shift_dist_weight();
}
inline float MlfDistanceWeight::centroid_shift_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.centroid_shift_dist_weight)
  return centroid_shift_dist_weight_;
}
inline void MlfDistanceWeight::set_centroid_shift_dist_weight(float value) {
  set_has_centroid_shift_dist_weight();
  centroid_shift_dist_weight_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.centroid_shift_dist_weight)
}

// optional float bbox_iou_dist_weight = 8 [default = 0];
inline bool MlfDistanceWeight::has_bbox_iou_dist_weight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MlfDistanceWeight::set_has_bbox_iou_dist_weight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MlfDistanceWeight::clear_has_bbox_iou_dist_weight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MlfDistanceWeight::clear_bbox_iou_dist_weight() {
  bbox_iou_dist_weight_ = 0;
  clear_has_bbox_iou_dist_weight();
}
inline float MlfDistanceWeight::bbox_iou_dist_weight() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceWeight.bbox_iou_dist_weight)
  return bbox_iou_dist_weight_;
}
inline void MlfDistanceWeight::set_bbox_iou_dist_weight(float value) {
  set_has_bbox_iou_dist_weight();
  bbox_iou_dist_weight_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfDistanceWeight.bbox_iou_dist_weight)
}

// -------------------------------------------------------------------

// MlfDistanceConfig

// repeated .apollo.perception.lidar.MlfDistanceWeight foreground_weights = 1;
inline int MlfDistanceConfig::foreground_weights_size() const {
  return foreground_weights_.size();
}
inline void MlfDistanceConfig::clear_foreground_weights() {
  foreground_weights_.Clear();
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::mutable_foreground_weights(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return foreground_weights_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >*
MlfDistanceConfig::mutable_foreground_weights() {
  // @@protoc_insertion_point(field_mutable_list:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return &foreground_weights_;
}
inline const ::apollo::perception::lidar::MlfDistanceWeight& MlfDistanceConfig::foreground_weights(int index) const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return foreground_weights_.Get(index);
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::add_foreground_weights() {
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return foreground_weights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >&
MlfDistanceConfig::foreground_weights() const {
  // @@protoc_insertion_point(field_list:apollo.perception.lidar.MlfDistanceConfig.foreground_weights)
  return foreground_weights_;
}

// repeated .apollo.perception.lidar.MlfDistanceWeight background_weights = 2;
inline int MlfDistanceConfig::background_weights_size() const {
  return background_weights_.size();
}
inline void MlfDistanceConfig::clear_background_weights() {
  background_weights_.Clear();
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::mutable_background_weights(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return background_weights_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >*
MlfDistanceConfig::mutable_background_weights() {
  // @@protoc_insertion_point(field_mutable_list:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return &background_weights_;
}
inline const ::apollo::perception::lidar::MlfDistanceWeight& MlfDistanceConfig::background_weights(int index) const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return background_weights_.Get(index);
}
inline ::apollo::perception::lidar::MlfDistanceWeight* MlfDistanceConfig::add_background_weights() {
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return background_weights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::perception::lidar::MlfDistanceWeight >&
MlfDistanceConfig::background_weights() const {
  // @@protoc_insertion_point(field_list:apollo.perception.lidar.MlfDistanceConfig.background_weights)
  return background_weights_;
}

// -------------------------------------------------------------------

// MlfTrackObjectMatcherConfig

// optional string foreground_mathcer_method = 1 [default = "MultiHmBipartiteGraphMatcher"];
inline bool MlfTrackObjectMatcherConfig::has_foreground_mathcer_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MlfTrackObjectMatcherConfig::set_has_foreground_mathcer_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MlfTrackObjectMatcherConfig::clear_has_foreground_mathcer_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MlfTrackObjectMatcherConfig::clear_foreground_mathcer_method() {
  foreground_mathcer_method_.ClearToDefaultNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get());
  clear_has_foreground_mathcer_method();
}
inline const ::std::string& MlfTrackObjectMatcherConfig::foreground_mathcer_method() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
  return foreground_mathcer_method_.GetNoArena();
}
inline void MlfTrackObjectMatcherConfig::set_foreground_mathcer_method(const ::std::string& value) {
  set_has_foreground_mathcer_method();
  foreground_mathcer_method_.SetNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(), value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
}
#if LANG_CXX11
inline void MlfTrackObjectMatcherConfig::set_foreground_mathcer_method(::std::string&& value) {
  set_has_foreground_mathcer_method();
  foreground_mathcer_method_.SetNoArena(
    &::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
}
#endif
inline void MlfTrackObjectMatcherConfig::set_foreground_mathcer_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_foreground_mathcer_method();
  foreground_mathcer_method_.SetNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
}
inline void MlfTrackObjectMatcherConfig::set_foreground_mathcer_method(const char* value, size_t size) {
  set_has_foreground_mathcer_method();
  foreground_mathcer_method_.SetNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
}
inline ::std::string* MlfTrackObjectMatcherConfig::mutable_foreground_mathcer_method() {
  set_has_foreground_mathcer_method();
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
  return foreground_mathcer_method_.MutableNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get());
}
inline ::std::string* MlfTrackObjectMatcherConfig::release_foreground_mathcer_method() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
  if (!has_foreground_mathcer_method()) {
    return NULL;
  }
  clear_has_foreground_mathcer_method();
  return foreground_mathcer_method_.ReleaseNonDefaultNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get());
}
inline void MlfTrackObjectMatcherConfig::set_allocated_foreground_mathcer_method(::std::string* foreground_mathcer_method) {
  if (foreground_mathcer_method != NULL) {
    set_has_foreground_mathcer_method();
  } else {
    clear_has_foreground_mathcer_method();
  }
  foreground_mathcer_method_.SetAllocatedNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_foreground_mathcer_method_.get(), foreground_mathcer_method);
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.MlfTrackObjectMatcherConfig.foreground_mathcer_method)
}

// optional string background_matcher_method = 2 [default = "GnnBipartiteGraphMatcher"];
inline bool MlfTrackObjectMatcherConfig::has_background_matcher_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MlfTrackObjectMatcherConfig::set_has_background_matcher_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MlfTrackObjectMatcherConfig::clear_has_background_matcher_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MlfTrackObjectMatcherConfig::clear_background_matcher_method() {
  background_matcher_method_.ClearToDefaultNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get());
  clear_has_background_matcher_method();
}
inline const ::std::string& MlfTrackObjectMatcherConfig::background_matcher_method() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
  return background_matcher_method_.GetNoArena();
}
inline void MlfTrackObjectMatcherConfig::set_background_matcher_method(const ::std::string& value) {
  set_has_background_matcher_method();
  background_matcher_method_.SetNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(), value);
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
}
#if LANG_CXX11
inline void MlfTrackObjectMatcherConfig::set_background_matcher_method(::std::string&& value) {
  set_has_background_matcher_method();
  background_matcher_method_.SetNoArena(
    &::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
}
#endif
inline void MlfTrackObjectMatcherConfig::set_background_matcher_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_background_matcher_method();
  background_matcher_method_.SetNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
}
inline void MlfTrackObjectMatcherConfig::set_background_matcher_method(const char* value, size_t size) {
  set_has_background_matcher_method();
  background_matcher_method_.SetNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
}
inline ::std::string* MlfTrackObjectMatcherConfig::mutable_background_matcher_method() {
  set_has_background_matcher_method();
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
  return background_matcher_method_.MutableNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get());
}
inline ::std::string* MlfTrackObjectMatcherConfig::release_background_matcher_method() {
  // @@protoc_insertion_point(field_release:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
  if (!has_background_matcher_method()) {
    return NULL;
  }
  clear_has_background_matcher_method();
  return background_matcher_method_.ReleaseNonDefaultNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get());
}
inline void MlfTrackObjectMatcherConfig::set_allocated_background_matcher_method(::std::string* background_matcher_method) {
  if (background_matcher_method != NULL) {
    set_has_background_matcher_method();
  } else {
    clear_has_background_matcher_method();
  }
  background_matcher_method_.SetAllocatedNoArena(&::apollo::perception::lidar::MlfTrackObjectMatcherConfig::_i_give_permission_to_break_this_code_default_background_matcher_method_.get(), background_matcher_method);
  // @@protoc_insertion_point(field_set_allocated:apollo.perception.lidar.MlfTrackObjectMatcherConfig.background_matcher_method)
}

// optional float bound_value = 3 [default = 100];
inline bool MlfTrackObjectMatcherConfig::has_bound_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MlfTrackObjectMatcherConfig::set_has_bound_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MlfTrackObjectMatcherConfig::clear_has_bound_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MlfTrackObjectMatcherConfig::clear_bound_value() {
  bound_value_ = 100;
  clear_has_bound_value();
}
inline float MlfTrackObjectMatcherConfig::bound_value() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackObjectMatcherConfig.bound_value)
  return bound_value_;
}
inline void MlfTrackObjectMatcherConfig::set_bound_value(float value) {
  set_has_bound_value();
  bound_value_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackObjectMatcherConfig.bound_value)
}

// optional float max_match_distance = 4 [default = 4];
inline bool MlfTrackObjectMatcherConfig::has_max_match_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MlfTrackObjectMatcherConfig::set_has_max_match_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MlfTrackObjectMatcherConfig::clear_has_max_match_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MlfTrackObjectMatcherConfig::clear_max_match_distance() {
  max_match_distance_ = 4;
  clear_has_max_match_distance();
}
inline float MlfTrackObjectMatcherConfig::max_match_distance() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackObjectMatcherConfig.max_match_distance)
  return max_match_distance_;
}
inline void MlfTrackObjectMatcherConfig::set_max_match_distance(float value) {
  set_has_max_match_distance();
  max_match_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackObjectMatcherConfig.max_match_distance)
}

// -------------------------------------------------------------------

// MlfTrackerConfig

// repeated string filter_name = 1;
inline int MlfTrackerConfig::filter_name_size() const {
  return filter_name_.size();
}
inline void MlfTrackerConfig::clear_filter_name() {
  filter_name_.Clear();
}
inline const ::std::string& MlfTrackerConfig::filter_name(int index) const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return filter_name_.Get(index);
}
inline ::std::string* MlfTrackerConfig::mutable_filter_name(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return filter_name_.Mutable(index);
}
inline void MlfTrackerConfig::set_filter_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  filter_name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MlfTrackerConfig::set_filter_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  filter_name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MlfTrackerConfig::set_filter_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filter_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline void MlfTrackerConfig::set_filter_name(int index, const char* value, size_t size) {
  filter_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline ::std::string* MlfTrackerConfig::add_filter_name() {
  // @@protoc_insertion_point(field_add_mutable:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return filter_name_.Add();
}
inline void MlfTrackerConfig::add_filter_name(const ::std::string& value) {
  filter_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
#if LANG_CXX11
inline void MlfTrackerConfig::add_filter_name(::std::string&& value) {
  filter_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
#endif
inline void MlfTrackerConfig::add_filter_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filter_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline void MlfTrackerConfig::add_filter_name(const char* value, size_t size) {
  filter_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.perception.lidar.MlfTrackerConfig.filter_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MlfTrackerConfig::filter_name() const {
  // @@protoc_insertion_point(field_list:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return filter_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MlfTrackerConfig::mutable_filter_name() {
  // @@protoc_insertion_point(field_mutable_list:apollo.perception.lidar.MlfTrackerConfig.filter_name)
  return &filter_name_;
}

// -------------------------------------------------------------------

// MlfMotionFilterConfig

// optional bool use_adaptive = 1 [default = true];
inline bool MlfMotionFilterConfig::has_use_adaptive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MlfMotionFilterConfig::set_has_use_adaptive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MlfMotionFilterConfig::clear_has_use_adaptive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MlfMotionFilterConfig::clear_use_adaptive() {
  use_adaptive_ = true;
  clear_has_use_adaptive();
}
inline bool MlfMotionFilterConfig::use_adaptive() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.use_adaptive)
  return use_adaptive_;
}
inline void MlfMotionFilterConfig::set_use_adaptive(bool value) {
  set_has_use_adaptive();
  use_adaptive_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.use_adaptive)
}

// optional bool use_breakdown = 2 [default = true];
inline bool MlfMotionFilterConfig::has_use_breakdown() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MlfMotionFilterConfig::set_has_use_breakdown() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MlfMotionFilterConfig::clear_has_use_breakdown() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MlfMotionFilterConfig::clear_use_breakdown() {
  use_breakdown_ = true;
  clear_has_use_breakdown();
}
inline bool MlfMotionFilterConfig::use_breakdown() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.use_breakdown)
  return use_breakdown_;
}
inline void MlfMotionFilterConfig::set_use_breakdown(bool value) {
  set_has_use_breakdown();
  use_breakdown_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.use_breakdown)
}

// optional bool use_convergence_boostup = 3 [default = true];
inline bool MlfMotionFilterConfig::has_use_convergence_boostup() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MlfMotionFilterConfig::set_has_use_convergence_boostup() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MlfMotionFilterConfig::clear_has_use_convergence_boostup() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MlfMotionFilterConfig::clear_use_convergence_boostup() {
  use_convergence_boostup_ = true;
  clear_has_use_convergence_boostup();
}
inline bool MlfMotionFilterConfig::use_convergence_boostup() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.use_convergence_boostup)
  return use_convergence_boostup_;
}
inline void MlfMotionFilterConfig::set_use_convergence_boostup(bool value) {
  set_has_use_convergence_boostup();
  use_convergence_boostup_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.use_convergence_boostup)
}

// optional double init_velocity_variance = 4 [default = 5];
inline bool MlfMotionFilterConfig::has_init_velocity_variance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MlfMotionFilterConfig::set_has_init_velocity_variance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MlfMotionFilterConfig::clear_has_init_velocity_variance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MlfMotionFilterConfig::clear_init_velocity_variance() {
  init_velocity_variance_ = 5;
  clear_has_init_velocity_variance();
}
inline double MlfMotionFilterConfig::init_velocity_variance() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.init_velocity_variance)
  return init_velocity_variance_;
}
inline void MlfMotionFilterConfig::set_init_velocity_variance(double value) {
  set_has_init_velocity_variance();
  init_velocity_variance_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.init_velocity_variance)
}

// optional double init_acceleration_variance = 5 [default = 10];
inline bool MlfMotionFilterConfig::has_init_acceleration_variance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MlfMotionFilterConfig::set_has_init_acceleration_variance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MlfMotionFilterConfig::clear_has_init_acceleration_variance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MlfMotionFilterConfig::clear_init_acceleration_variance() {
  init_acceleration_variance_ = 10;
  clear_has_init_acceleration_variance();
}
inline double MlfMotionFilterConfig::init_acceleration_variance() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.init_acceleration_variance)
  return init_acceleration_variance_;
}
inline void MlfMotionFilterConfig::set_init_acceleration_variance(double value) {
  set_has_init_acceleration_variance();
  init_acceleration_variance_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.init_acceleration_variance)
}

// optional double measured_velocity_variance = 6 [default = 0.4];
inline bool MlfMotionFilterConfig::has_measured_velocity_variance() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MlfMotionFilterConfig::set_has_measured_velocity_variance() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MlfMotionFilterConfig::clear_has_measured_velocity_variance() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MlfMotionFilterConfig::clear_measured_velocity_variance() {
  measured_velocity_variance_ = 0.4;
  clear_has_measured_velocity_variance();
}
inline double MlfMotionFilterConfig::measured_velocity_variance() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.measured_velocity_variance)
  return measured_velocity_variance_;
}
inline void MlfMotionFilterConfig::set_measured_velocity_variance(double value) {
  set_has_measured_velocity_variance();
  measured_velocity_variance_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.measured_velocity_variance)
}

// optional double predict_variance_per_sqrsec = 7 [default = 10];
inline bool MlfMotionFilterConfig::has_predict_variance_per_sqrsec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MlfMotionFilterConfig::set_has_predict_variance_per_sqrsec() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MlfMotionFilterConfig::clear_has_predict_variance_per_sqrsec() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MlfMotionFilterConfig::clear_predict_variance_per_sqrsec() {
  predict_variance_per_sqrsec_ = 10;
  clear_has_predict_variance_per_sqrsec();
}
inline double MlfMotionFilterConfig::predict_variance_per_sqrsec() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.predict_variance_per_sqrsec)
  return predict_variance_per_sqrsec_;
}
inline void MlfMotionFilterConfig::set_predict_variance_per_sqrsec(double value) {
  set_has_predict_variance_per_sqrsec();
  predict_variance_per_sqrsec_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.predict_variance_per_sqrsec)
}

// optional uint32 boostup_history_size_minimum = 8 [default = 3];
inline bool MlfMotionFilterConfig::has_boostup_history_size_minimum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MlfMotionFilterConfig::set_has_boostup_history_size_minimum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MlfMotionFilterConfig::clear_has_boostup_history_size_minimum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MlfMotionFilterConfig::clear_boostup_history_size_minimum() {
  boostup_history_size_minimum_ = 3u;
  clear_has_boostup_history_size_minimum();
}
inline ::google::protobuf::uint32 MlfMotionFilterConfig::boostup_history_size_minimum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.boostup_history_size_minimum)
  return boostup_history_size_minimum_;
}
inline void MlfMotionFilterConfig::set_boostup_history_size_minimum(::google::protobuf::uint32 value) {
  set_has_boostup_history_size_minimum();
  boostup_history_size_minimum_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.boostup_history_size_minimum)
}

// optional uint32 boostup_history_size_maximum = 9 [default = 6];
inline bool MlfMotionFilterConfig::has_boostup_history_size_maximum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MlfMotionFilterConfig::set_has_boostup_history_size_maximum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MlfMotionFilterConfig::clear_has_boostup_history_size_maximum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MlfMotionFilterConfig::clear_boostup_history_size_maximum() {
  boostup_history_size_maximum_ = 6u;
  clear_has_boostup_history_size_maximum();
}
inline ::google::protobuf::uint32 MlfMotionFilterConfig::boostup_history_size_maximum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.boostup_history_size_maximum)
  return boostup_history_size_maximum_;
}
inline void MlfMotionFilterConfig::set_boostup_history_size_maximum(::google::protobuf::uint32 value) {
  set_has_boostup_history_size_maximum();
  boostup_history_size_maximum_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.boostup_history_size_maximum)
}

// optional double converged_confidence_minimum = 10 [default = 0.5];
inline bool MlfMotionFilterConfig::has_converged_confidence_minimum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MlfMotionFilterConfig::set_has_converged_confidence_minimum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MlfMotionFilterConfig::clear_has_converged_confidence_minimum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MlfMotionFilterConfig::clear_converged_confidence_minimum() {
  converged_confidence_minimum_ = 0.5;
  clear_has_converged_confidence_minimum();
}
inline double MlfMotionFilterConfig::converged_confidence_minimum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.converged_confidence_minimum)
  return converged_confidence_minimum_;
}
inline void MlfMotionFilterConfig::set_converged_confidence_minimum(double value) {
  set_has_converged_confidence_minimum();
  converged_confidence_minimum_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.converged_confidence_minimum)
}

// optional double noise_maximum = 12 [default = 0.1];
inline bool MlfMotionFilterConfig::has_noise_maximum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MlfMotionFilterConfig::set_has_noise_maximum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MlfMotionFilterConfig::clear_has_noise_maximum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MlfMotionFilterConfig::clear_noise_maximum() {
  noise_maximum_ = 0.1;
  clear_has_noise_maximum();
}
inline double MlfMotionFilterConfig::noise_maximum() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.noise_maximum)
  return noise_maximum_;
}
inline void MlfMotionFilterConfig::set_noise_maximum(double value) {
  set_has_noise_maximum();
  noise_maximum_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.noise_maximum)
}

// optional double trust_orientation_range = 13 [default = 40];
inline bool MlfMotionFilterConfig::has_trust_orientation_range() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MlfMotionFilterConfig::set_has_trust_orientation_range() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MlfMotionFilterConfig::clear_has_trust_orientation_range() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MlfMotionFilterConfig::clear_trust_orientation_range() {
  trust_orientation_range_ = 40;
  clear_has_trust_orientation_range();
}
inline double MlfMotionFilterConfig::trust_orientation_range() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionFilterConfig.trust_orientation_range)
  return trust_orientation_range_;
}
inline void MlfMotionFilterConfig::set_trust_orientation_range(double value) {
  set_has_trust_orientation_range();
  trust_orientation_range_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionFilterConfig.trust_orientation_range)
}

// -------------------------------------------------------------------

// MlfMotionRefinerConfig

// optional double claping_acceleration_threshold = 1 [default = 10];
inline bool MlfMotionRefinerConfig::has_claping_acceleration_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MlfMotionRefinerConfig::set_has_claping_acceleration_threshold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MlfMotionRefinerConfig::clear_has_claping_acceleration_threshold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MlfMotionRefinerConfig::clear_claping_acceleration_threshold() {
  claping_acceleration_threshold_ = 10;
  clear_has_claping_acceleration_threshold();
}
inline double MlfMotionRefinerConfig::claping_acceleration_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionRefinerConfig.claping_acceleration_threshold)
  return claping_acceleration_threshold_;
}
inline void MlfMotionRefinerConfig::set_claping_acceleration_threshold(double value) {
  set_has_claping_acceleration_threshold();
  claping_acceleration_threshold_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionRefinerConfig.claping_acceleration_threshold)
}

// optional double claping_speed_threshold = 2 [default = 1];
inline bool MlfMotionRefinerConfig::has_claping_speed_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MlfMotionRefinerConfig::set_has_claping_speed_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MlfMotionRefinerConfig::clear_has_claping_speed_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MlfMotionRefinerConfig::clear_claping_speed_threshold() {
  claping_speed_threshold_ = 1;
  clear_has_claping_speed_threshold();
}
inline double MlfMotionRefinerConfig::claping_speed_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfMotionRefinerConfig.claping_speed_threshold)
  return claping_speed_threshold_;
}
inline void MlfMotionRefinerConfig::set_claping_speed_threshold(double value) {
  set_has_claping_speed_threshold();
  claping_speed_threshold_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfMotionRefinerConfig.claping_speed_threshold)
}

// -------------------------------------------------------------------

// MlfShapeFilterConfig

// optional double bottom_points_ignore_threshold = 1 [default = 0.1];
inline bool MlfShapeFilterConfig::has_bottom_points_ignore_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MlfShapeFilterConfig::set_has_bottom_points_ignore_threshold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MlfShapeFilterConfig::clear_has_bottom_points_ignore_threshold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MlfShapeFilterConfig::clear_bottom_points_ignore_threshold() {
  bottom_points_ignore_threshold_ = 0.1;
  clear_has_bottom_points_ignore_threshold();
}
inline double MlfShapeFilterConfig::bottom_points_ignore_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfShapeFilterConfig.bottom_points_ignore_threshold)
  return bottom_points_ignore_threshold_;
}
inline void MlfShapeFilterConfig::set_bottom_points_ignore_threshold(double value) {
  set_has_bottom_points_ignore_threshold();
  bottom_points_ignore_threshold_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfShapeFilterConfig.bottom_points_ignore_threshold)
}

// optional double top_points_ignore_threshold = 2 [default = 1.6];
inline bool MlfShapeFilterConfig::has_top_points_ignore_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MlfShapeFilterConfig::set_has_top_points_ignore_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MlfShapeFilterConfig::clear_has_top_points_ignore_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MlfShapeFilterConfig::clear_top_points_ignore_threshold() {
  top_points_ignore_threshold_ = 1.6;
  clear_has_top_points_ignore_threshold();
}
inline double MlfShapeFilterConfig::top_points_ignore_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfShapeFilterConfig.top_points_ignore_threshold)
  return top_points_ignore_threshold_;
}
inline void MlfShapeFilterConfig::set_top_points_ignore_threshold(double value) {
  set_has_top_points_ignore_threshold();
  top_points_ignore_threshold_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfShapeFilterConfig.top_points_ignore_threshold)
}

// -------------------------------------------------------------------

// MlfEngineConfig

// repeated string main_sensor = 1;
inline int MlfEngineConfig::main_sensor_size() const {
  return main_sensor_.size();
}
inline void MlfEngineConfig::clear_main_sensor() {
  main_sensor_.Clear();
}
inline const ::std::string& MlfEngineConfig::main_sensor(int index) const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return main_sensor_.Get(index);
}
inline ::std::string* MlfEngineConfig::mutable_main_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return main_sensor_.Mutable(index);
}
inline void MlfEngineConfig::set_main_sensor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  main_sensor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MlfEngineConfig::set_main_sensor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  main_sensor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MlfEngineConfig::set_main_sensor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  main_sensor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline void MlfEngineConfig::set_main_sensor(int index, const char* value, size_t size) {
  main_sensor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline ::std::string* MlfEngineConfig::add_main_sensor() {
  // @@protoc_insertion_point(field_add_mutable:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return main_sensor_.Add();
}
inline void MlfEngineConfig::add_main_sensor(const ::std::string& value) {
  main_sensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
#if LANG_CXX11
inline void MlfEngineConfig::add_main_sensor(::std::string&& value) {
  main_sensor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
#endif
inline void MlfEngineConfig::add_main_sensor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  main_sensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline void MlfEngineConfig::add_main_sensor(const char* value, size_t size) {
  main_sensor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.perception.lidar.MlfEngineConfig.main_sensor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MlfEngineConfig::main_sensor() const {
  // @@protoc_insertion_point(field_list:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return main_sensor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MlfEngineConfig::mutable_main_sensor() {
  // @@protoc_insertion_point(field_mutable_list:apollo.perception.lidar.MlfEngineConfig.main_sensor)
  return &main_sensor_;
}

// optional bool use_histogram_for_match = 2 [default = true];
inline bool MlfEngineConfig::has_use_histogram_for_match() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MlfEngineConfig::set_has_use_histogram_for_match() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MlfEngineConfig::clear_has_use_histogram_for_match() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MlfEngineConfig::clear_use_histogram_for_match() {
  use_histogram_for_match_ = true;
  clear_has_use_histogram_for_match();
}
inline bool MlfEngineConfig::use_histogram_for_match() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.use_histogram_for_match)
  return use_histogram_for_match_;
}
inline void MlfEngineConfig::set_use_histogram_for_match(bool value) {
  set_has_use_histogram_for_match();
  use_histogram_for_match_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.use_histogram_for_match)
}

// optional uint32 histogram_bin_size = 3 [default = 10];
inline bool MlfEngineConfig::has_histogram_bin_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MlfEngineConfig::set_has_histogram_bin_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MlfEngineConfig::clear_has_histogram_bin_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MlfEngineConfig::clear_histogram_bin_size() {
  histogram_bin_size_ = 10u;
  clear_has_histogram_bin_size();
}
inline ::google::protobuf::uint32 MlfEngineConfig::histogram_bin_size() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.histogram_bin_size)
  return histogram_bin_size_;
}
inline void MlfEngineConfig::set_histogram_bin_size(::google::protobuf::uint32 value) {
  set_has_histogram_bin_size();
  histogram_bin_size_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.histogram_bin_size)
}

// optional bool output_predict_objects = 4 [default = false];
inline bool MlfEngineConfig::has_output_predict_objects() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MlfEngineConfig::set_has_output_predict_objects() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MlfEngineConfig::clear_has_output_predict_objects() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MlfEngineConfig::clear_output_predict_objects() {
  output_predict_objects_ = false;
  clear_has_output_predict_objects();
}
inline bool MlfEngineConfig::output_predict_objects() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.output_predict_objects)
  return output_predict_objects_;
}
inline void MlfEngineConfig::set_output_predict_objects(bool value) {
  set_has_output_predict_objects();
  output_predict_objects_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.output_predict_objects)
}

// optional double reserved_invisible_time = 5 [default = 0.2];
inline bool MlfEngineConfig::has_reserved_invisible_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MlfEngineConfig::set_has_reserved_invisible_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MlfEngineConfig::clear_has_reserved_invisible_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MlfEngineConfig::clear_reserved_invisible_time() {
  reserved_invisible_time_ = 0.2;
  clear_has_reserved_invisible_time();
}
inline double MlfEngineConfig::reserved_invisible_time() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.reserved_invisible_time)
  return reserved_invisible_time_;
}
inline void MlfEngineConfig::set_reserved_invisible_time(double value) {
  set_has_reserved_invisible_time();
  reserved_invisible_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.reserved_invisible_time)
}

// optional bool use_frame_timestamp = 6 [default = false];
inline bool MlfEngineConfig::has_use_frame_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MlfEngineConfig::set_has_use_frame_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MlfEngineConfig::clear_has_use_frame_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MlfEngineConfig::clear_use_frame_timestamp() {
  use_frame_timestamp_ = false;
  clear_has_use_frame_timestamp();
}
inline bool MlfEngineConfig::use_frame_timestamp() const {
  // @@protoc_insertion_point(field_get:apollo.perception.lidar.MlfEngineConfig.use_frame_timestamp)
  return use_frame_timestamp_;
}
inline void MlfEngineConfig::set_use_frame_timestamp(bool value) {
  set_has_use_frame_timestamp();
  use_frame_timestamp_ = value;
  // @@protoc_insertion_point(field_set:apollo.perception.lidar.MlfEngineConfig.use_frame_timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lidar
}  // namespace perception
}  // namespace apollo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_multi_5flidar_5ffusion_5fconfig_2eproto
